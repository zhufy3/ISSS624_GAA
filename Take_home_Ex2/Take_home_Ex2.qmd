---
title: "Inclass Exercise 3"
author: "ZHU Fangyuan"
editor: visual
---

# Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods

## Objectives

In this take-home exercise we will regionalise Nigeria by using, but not limited to the following measures:

-   Total number of functional water points

-   Total number of nonfunctional water points

-   Percentage of functional water points

-   Percentage of non-functional water points

-   Percentage of main water point technology (i.e. Hand Pump)

-   Percentage of usage capacity (i.e. \< 1000, \>=1000)

-   Percentage of rural water points

## Overview

In this in-class exercise, we will learn several useful ways to deal with geospatial and aspatial data of **Nigeria** case! Let us get started now!

## 1 Packages Used

Packages below will be used in this in-class exercise:

-   ***sf*** : importing and processing geospatial data

-   ***tidyverse:*** importing and processing non-spatial data. In this exercise, readr package will be used for importing wkt data and dplyr package will be used to wrangling the data

-   **rgdal, spdep** for spatial data handling

-   **readr, ggplot2, dplyr** for attribute data handling

-   **tmap** for choropleth mapping

-   **corrplot, ggpubr, TSP, heatmaply** for multivariate data visualisation

-   **cluster, ClustGeo** for cluster analysis

```{r eval=FALSE}
pacman::p_load(rgdal, spdep, tmap, sf, readr, ggplot2, dplyr,
               ggpubr, cluster, factoextra, NbClust,
               TSP, heatmaply, corrplot, psych, tidyverse,ClustGeo)
```

## 2 Data Used

In this exercise, two data sets will be used:

-   **Aspatial data:** from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/). We will use the WPdx+ data set.
-   **Geospatial data:** Nigeria Level-2 Administrative Boundary (also known as Local Government Area) polygon features GIS data from the [Humanitarian Data Exchange](https://data.humdata.org/) portal or [geoBoundaries](https://www.geoboundaries.org/).

## 3 Data Preparation

### 3.1 Importing water point data

First, let us import the data used into the R environment using code below.

And the function `filter()` of ***dplyr*** will be used to filter data only belonging to Nigeria.

```{r eval=FALSE}
wp_nga <- read_csv("aspatial/WPdx.csv")%>%
  filter(`#clean_country_name`=="Nigeria")
```

Noted that the data frame contains 95008 observations and 70 variables.

### 3.2 Convert Well Known Text (wkt) data

Notice that the newly imported tibble data frame (i.e. wp_nga) contains a field called *New Georeferenced Column* which represent spatial data in a textual format. In fact, this kind of text file is popularly known as ***Well Known Text*** in short ***wkt***. So we need to convert the *wkt* data into **sf** data.frame for subsequent analysis.

First, `st_as_sfc()` of ***sf*** package is used to derive a new field called *Geometry* as shown in the code chunk below.

```{r eval=FALSE}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)
```

Next, `st_sf()` will be used to convert the *tibble* data frame into *sf* data frame. In addition, we use ***Projected Coordinate System*** for convenience in our analysis, so we set the *EPSG* code as ***26391.***

```{r eval=FALSE}
wp_sf <- st_sf(wp_nga, crs=26391) 
wp_sf
```

The output reveals that we have:

-   Simple feature collection withe 95008 features and 70 fields.

-   Geometry type: POINT

-   Projected CRS: Minna / Nigeria west belt

### 3.3 Importing Nigeria LGA boundary data

Now we import the geospatial data with the same ***Projected Coordinate System (EPSG code:26391)*** into the R environment, and we only use *shapeName* column because this boundary data only provides a basic map of the contry.

```{r eval=FALSE}
nga<-st_read(dsn = "geospatial",
             layer = "geoBoundaries-NGA-ADM2",
             crs=26391)%>%
  select(shapeName)
```

The output reveals that we have:

-   Simple feature collection withe 774 features and 5 fields.

-   Geometry type: MULTIPOLYGON

-   Projected CRS: Minna / Nigeria west belt

Now we can write the tidy *sf* data frame ***nga*** as a *rds* files with code chunk below.

```{r eval=FALSE}
write_rds(nga,"geodata/nga.rds")
```

## 4 Data Wrangling

### 4.1 Data issues

Before we go ahead, we are supposed to deal with data issues first.

#### 4.1.1 Duplicate fields and features

##### 4.1.1.1 Duplicate fields

We now come to check if there are duplicate fields in the *wp_sf* data frame using code chunk below.

```{r eval=FALSE}
dup_col <- duplicated(t(wp_sf))
colnames(wp_sf[dup_col])
```

Noted that there are 7 duplicated columns *#clean_adm4, #rehabilitator, #fecal_coliform_presence, #scheme_id, lon_deg_original, updated_timestamp* and *Geometry*. However, taking a glimpse on the data table, these former 6 columns have duplicated columns because their values are all missed. And as shown in sippet below, we do see column *#water_tech_clean* and *#water_tech_category* are almost the same with some little differences.

![](images/tempsnip-01.png)

Therefore, we only use *#water_tech_clean* as our object of analysis because it describe observations more simplified.

We now come to check if there are duplicate features in the *wp_sf* data frame using code chunk below.

```{r eval=FALSE}
dup=which(duplicated(wp_sf))
dup
```

As the output reveals, there are no observations duplicated in *wp_sf* data frame. Then we use the same codes to check if there are duplicated features and fields in the *nga* data frame.

```{r eval=FALSE}
nga<-read_rds("geodata/nga.rds")
dup_coln<-which(duplicated(t(nga)))
dup_n<-which(duplicated(nga))
print(dup_n)
print(dup_coln)
```

As the output reveals, there are no duplicated features and fields in the *nga* data frame.

#### 4.1.2 Missing values

For convenience case, we first rename the columns we pay attention to in this project, which are:

-   *#status_clean*

-   *#water_tech_clean* or *#water_tech_category* (these two columns are identical)

-   *is_urban*

-   *usage_capacity*

We first rename columns *#status_clean,* *#water_tech_category* and *usage_capacity* which are untidy enough.

```{r eval=FALSE}
wp_sf<-wp_sf%>%
  rename(`status_cle`=`#status_clean`)%>%
  rename(water_tech=`#water_tech_category`)%>%
  rename(usage_cap=usage_capacity)%>%
  rename(wptpp=water_point_population)%>%
  rename(locpp=local_population_1km)
```

Now columns *#status_clean* and *#water_tech_category* are changed as *status_cle,* *water_tech* and *usage_cap.*

Then let us select the columns which will be used in the analysis, to make the data frame tidier by using codes below.

```{r eval=FALSE}
wp_sf<-wp_sf%>%
  select(c(1,10,22,42,43,46,47))
write_rds(wp_sf,"geodata/wp_sf.rds")
```

Let us see some statistics summary of the data frame with codes below and check missing values in the *wp_sf* data frame.

```{r eval=FALSE}
summary(wp_sf[rowSums(is.na(wp_sf))!=0,])
```

Noted from the output above that the variable *water_tech* has 11225 *NAs,* so does variable *status_cle. wptpp* and *locpp* both have 529 NAs. And no missing values in other variables which are *row_id,* *usage_cap* and *is_urban.*

Let us see statistics summary of the missing values in LGA boundary data *nga* data frame with the same codes shown below.

```{r eval=FALSE}
summary(nga[rowSums(is.na(nga))!=0,])
```

As we can see the summary information above, there is no missing value in LGA boundary data.

#### 4.1.3 Recoding missing values

In order to smoothly proceed our analysis without errors and warnings, it will make sense to recode the *NAs* in columns, however, we may consider replace the *NAs with different methods in different contexts.* Therefore, for ***water_tech*** with **mode** of the column's values.

First we write a function ***getmode*** to get the mode of a list of values using codes below.

```{r}
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

```

Then we replace the missing values with **Mode of the column's values.**

```{r eval=FALSE}
wp_sf<-wp_sf%>%
  mutate(water_tech=replace_na(water_tech,getmode(water_tech)))
```

However, for *status_cle,* it is irrational to use **mode** to replace the missing values.

```{r eval=FALSE}
getmode(wp_sf$status_cle)
```

Because as the output shown above, the mode for *status_cle* is *Functional,* but **from my perspective,** it is mostly impossible that functional water points were missed to be recorded. Therefore, those missing values are probably nonfunctional water points. We replace missing values in *status_cle* with *Non-Functional.*

```{r eval=FALSE}
wp_sf<-wp_sf%>%
  mutate(status_cle = replace_na(status_cle, "Non-Functional"))
```

In addition, we should check the status of water points where there are missing values in *water point population* and *local population \<1km* using code chunk below.

```{r eval=FALSE}
wp_sf[is.na(wp_sf$wptpp)==1,]%>%
  group_by(status_cle)%>%
  summarise(n=n())

wp_sf[is.na(wp_sf$locpp)==1,]%>%
  group_by(status_cle)%>%
  summarise(n=n())
```

Noticed that water points where there are missing values for populations are either *Abandoned/Decommissioned* or *Non-Functional water points.* Therefore, we assume there are no people living where there is a missing value and recode NAs with 0 as shown below.

```{r eval=FALSE}
wp_sf<-wp_sf%>%
  mutate(wptpp = replace_na(wptpp,0))

wp_sf<-wp_sf%>%
  mutate(locpp = replace_na(locpp,0))
```

Before we start our journey on creating new variables, let us take a look on statistics summary of the *wp_sf* data frame with codes below.

```{r eval=FALSE}
wp_sf%>%
  group_by(water_tech)%>%
  summarise(n=n())
```

```{r eval=FALSE}
wp_sf%>%
  group_by(status_cle)%>%
  summarise(n=n())
```

```{r eval=FALSE}
wp_sf%>%
  group_by(usage_cap)%>%
  summarise(n=n())

wp_sf%>%
  group_by(is_urban)%>%
  summarise(n=n())
```

## 5 Data Wrangling

### 5.1 Derive new variables

Then we are supposed to extract variables we will pay attention to in this exercise, and store them in specific data frame. These variables are:

-   Total number of **functional** water points

-   Total number of **non-functional** water points

-   Total number of main water point technology (i.e. *Hand pump*)

-   Total number of usage capacity

-   Total number of rural water points

We first create a data frame for *Non-Functional water points.* For rational reasons, *Abandoned/Decommissioned* and *Abandoned* should also be considered as *Non-Functional water points,* so we put water points belong to there two definitions into Non-Functional data frame using codes below.

```{r eval=FALSE}
wpt_nonfunctional <- wp_sf %>%
  filter(status_cle %in%
           c("Abandoned/Decommissioned", 
             "Abandoned",
             "Non-Functional",
             "Non functional due to dry season",
             "Non-Functional due to dry season"))
```

We now create data frames for *Functional water points, Hand-pump water points, usage capacity \>=1000, usage capacity\<1000,* and *rural water points* using the same methods.

```{r eval=FALSE}
wpt_functional <- wp_sf %>%
  filter(status_cle %in%
           c("Functional",
             "Functional but needs repair",
             "Functional but not in use"))

wpt_hand <- wp_sf %>%
  filter(water_tech %in%
           "Hand Pump")

wpt_cap_over <- wp_sf %>%
  filter(usage_cap>=1000)

wpt_cap_less<-wp_sf%>%
  filter(usage_cap<1000)

wpt_rural<-wp_sf%>%
  filter(is_urban==FALSE)

wpt_wptpp<-wp_sf%>%
  filter(wptpp>mean(wptpp))

wpt_locpp<-wp_sf%>%
  filter(locpp>mean(locpp))

```

Now we count the number of *Total,* *Functional water points, Non-Functional water points, Hand-pump water points, usage capacity \>=1000, usage capacity\<1000,* and *rural water points* at LGA level using *st_intersects()*.

```{r eval=FALSE}
FC<- lengths(st_intersects(nga, wpt_nonfunctional))
NFC<- lengths(st_intersects(nga, wpt_functional))
TT<-lengths(st_intersects(nga, wp_sf))
HP<-lengths(st_intersects(nga,wpt_hand))
UO<-lengths(st_intersects(nga,wpt_cap_over))
UL<-lengths(st_intersects(nga,wpt_cap_less))
RR<-lengths(st_intersects(nga,wpt_rural))
WP<-lengths(st_intersects(nga,wpt_wptpp))
LP<-lengths(st_intersects(nga,wpt_locpp))


```

We merge the count of *Total,* *Functional water points, Non-Functional water points, Hand-pump water points, usage capacity \>=1000, usage capacity\<1000,* and *rural water points* in polygons with LGA data table *nga* as *nga_wp* using codes below.

```{r eval=FALSE}
nga_wp <- nga %>% 
  mutate(`total wpt` = TT) %>%
  mutate(`functional wpt` = FC) %>%
  mutate(`non-functional wpt` = NFC)%>%
  mutate(`hand-pump wpt`=HP)%>%
  mutate(`usage cap>=1000`=UO)%>%
  mutate(`usage cap<1000`=UL)%>%
  mutate(`rural wpt`=RR)%>%
  mutate(`wpt pop`=WP)%>%
  mutate(`local pop`=LP)
```

Then we calculate the percentages of numbers of *Functional water points, Non-Functional water points, Hand-pump water points, usage capacity \>=1000, usage capacity\<1000,* and *rural water points* in each polygon, and merge it with *nga_wp* data table.

```{r eval=FALSE}
nga_wp <- nga_wp %>%
  mutate(pct_functional = `functional wpt`/`total wpt`) %>%
  mutate(`pct_non-functional` = `non-functional wpt`/`total wpt`) %>%
  mutate(`pct_hand-pump`=`hand-pump wpt`/`total wpt`)%>%
  mutate(`pct_cap>=1000`=`usage cap>=1000`/`total wpt`)%>%
  mutate(`pct_cap<1000`=`usage cap<1000`/`total wpt`)%>%
  mutate(`pct_rural`=`rural wpt`/`total wpt`)%>%
  mutate(`pct_pop`=`wpt pop`/`total wpt`)%>%
  mutate(`pct_localpop`=`local pop`/`total wpt`)


```

We can quickly look at the data frame by using codes below.

```{r eval=FALSE}
head(nga_wp,10)
```

As shown, there are some percentage becomes *NaN* because the *total wpt* is 0. We should recode these NA as 0.

```{r eval=FALSE}
nga_wp <- nga_wp %>%
  mutate(pct_functional = replace_na(pct_functional,0))%>%
  mutate(`pct_non-functional`=replace_na(`pct_non-functional`,0))%>%
  mutate(`pct_hand-pump`=replace_na(`pct_hand-pump`,0))%>%
  mutate(`pct_cap>=1000`=replace_na(`pct_cap>=1000`,0))%>%
  mutate(`pct_cap<1000`=replace_na(`pct_cap<1000`,0))%>%
  mutate(`pct_rural`=replace_na(`pct_rural`,0))%>%
  mutate(`pct_rural`=replace_na(`pct_pop`,0))%>%
  mutate(`pct_rural`=replace_na(`pct_localpop`,0))
```

We can quickly look at the data frame after modified by using codes below.

```{r eval=FALSE}
head(nga_wp,10)
```

Now we store the file *nga_wp* as a rds file.

```{r eval=FALSE}
write_rds(nga_wp,"geodata/nga_wp.rds")
```

### 5.2 Exploratory Data Analysis (EDA)

Counts of variables only have little meaning for our analysis. We focus on the percentage of number for each variable in a specific polygon. We now plot the histgram of frequency of ratio of all percentages to analyse their distributions.

```{r}
nga_wp<-read_rds("geodata/nga_wp.rds")
pct_func <- ggplot(data=nga_wp, 
             aes(x= `pct_functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light grey")

pct_nonfunc <- ggplot(data=nga_wp, 
             aes(x= `pct_non-functional`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light grey")

pct_hand <- ggplot(data=nga_wp, 
             aes(x= `pct_hand-pump`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light grey")

pct_capov <- ggplot(data=nga_wp, 
             aes(x= `pct_cap>=1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light grey")

pct_capls <- ggplot(data=nga_wp, 
             aes(x= `pct_cap<1000`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light grey")

pct_rural <- ggplot(data=nga_wp, 
             aes(x= `pct_rural`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light grey")

ggarrange(pct_func, pct_nonfunc, pct_hand, pct_capov, pct_capls, pct_rural, 
          ncol = 3, 
          nrow = 2)
```

Noted that the percentage of *Hand pump water points, water points with usage capacity \>=1000, water points with usage capacity \<1000 and rural water points* are highly skewed. More specific, in ADMIN2 districts, most of them have half functional water points and non-functional water points and most of them have water points with usage capacity less than 1000. In addition, most of the water points are located in rural areas, and supported by hand pumps.

We can also check outliers of them.

```{r}
pct_func <- ggplot(data=nga_wp, 
             aes(x= `pct_functional`)) +
  geom_boxplot(color="black", 
                 fill="light grey")

pct_nonfunc <- ggplot(data=nga_wp, 
             aes(x= `pct_non-functional`)) +
  geom_boxplot(color="black", 
                 fill="light grey")

pct_hand <- ggplot(data=nga_wp, 
             aes(x= `pct_hand-pump`)) +
  geom_boxplot(color="black", 
                 fill="light grey")

pct_capov <- ggplot(data=nga_wp, 
             aes(x= `pct_cap>=1000`)) +
  geom_boxplot(color="black", 
                 fill="light grey")

pct_caple <- ggplot(data=nga_wp, 
             aes(x= `pct_cap<1000`)) +
  geom_boxplot(color="black", 
                 fill="light grey")

pct_rural <- ggplot(data=nga_wp, 
             aes(x= `pct_rural`)) +
  geom_boxplot(color="black", 
                 fill="light grey")

ggarrange(pct_func, pct_nonfunc, pct_hand, pct_capov, pct_capls, pct_rural, 
          ncol = 3, 
          nrow = 2)
```

Noted that since we use ratio, the values are relatively congregated without outliers.

### 5.3 Choropleth map

We can draw choropleth map to visualize the distribution of each percentage variables in each polygon using code below.

```{r}
pct_func.map <- tm_shape(nga_wp) + 
  tm_fill(col = "pct_functional",
          n = 5,
          style = "jenks", 
          title = "Percentage of Functional Water Points") + 
  tm_borders(alpha = 0.5) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE)

pct_nonfunc.map<-tm_shape(nga_wp)+
  tm_fill(col="pct_non-functional",
          n=5,
          stype="jenks",
          title = "Percentage of Non-Functional Water Points")+ 
  tm_borders(alpha = 0.5) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE)

pct_hand.map<-tm_shape(nga_wp)+
  tm_fill(col="pct_hand-pump",
          n=5,
          style="jenks",
          title="Percentage of Non-Functional Water Points")+ 
  tm_borders(alpha = 0.5) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE)

pct_capov.map<-tm_shape(nga_wp)+
  tm_fill(col="pct_cap>=1000",
          n=5,
          style="jenks",
          title="Percentage of Usage Capacity >=1000 Water Points")+ 
  tm_borders(alpha = 0.5) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE)

pct_caple.map<-tm_shape(nga_wp)+
  tm_fill(col="pct_cap<1000",
          n=5,
          style="jenks",
          title="Percentage of Usage Capacity <1000 Water Points")+ 
  tm_borders(alpha = 0.5) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE)

pct_rural.map<-tm_shape(nga_wp)+
  tm_fill(col="pct_rural",
          n=5,
          style="jenks",
          title="Percentage of Rural Water Points")+ 
  tm_borders(alpha = 0.5)+
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE) 

tmap_arrange(pct_func.map, pct_nonfunc.map, pct_hand.map, pct_capov.map, pct_caple.map, pct_rural.map, 
          ncol = 2)
```

From the plots above, notice that areas in the north of the country have higher rate of functional water points, therefore, most water points in the south areas are non-functional. In addition, 50% of the country is equipped with hand-pumped water, which is low mechanical. The distributions of *Hand-pumped water points* and *water points with less than 1000 usage capacity* is aligned with each other. Lastly, almost water points are located in rural areas around the country.

## 6 Correlation Analysis

Before we start clustering, the first thing should be checking correlation between variables. We can use *corrplot.mixed()* function of ***corrplot*** package to visualise and analyse the correlation of the input variables.

```{r}
cluster_vars <- nga_wp %>%
  st_set_geometry(NULL)

cluster_vars.cor = cor(cluster_vars[,9:14])
cluster_vars.cor

corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

From the proximity matrix above, noticed that percentage of **functional** water point and percentage of **non**-**functional** water point have highly correlation of -0.86 (\<-0.85); percentage of **hand**-**pumped** water point and **usage capacity \>=1000** water point have highly correlation of -0.90 (\<-0.85); percentage of **hand-pumped** water point and **usage capacity \<1000** water point have highly correlation of 0.99 (\>0.85); percentage of **usage capacity \<1000** water point and **usage capacity \>=1000** water point have highly correlation of -0.91 (\<-0.85). Therefore, we remove *pct_functional, pct_hand-pump,* and *pct_cap\>1000.*
